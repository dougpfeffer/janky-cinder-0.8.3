<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
	<head>
		<meta content="text/html; charset=ISO-8859-1" http-equiv="content-type"><title>Cinder</title>
		<link rel="stylesheet" href="cinder_doxygen.css" type="text/css" media="screen" />
		<script type="text/javascript" src="jquery-1.4.2.min.js"></script>
		<script type="text/javascript" src="jquery.lightbox-0.5.pack.js"></script>		
	</head>
<body>	
<div class="wrapper">
	<div id="header">
		<h1><a href="http://libcinder.org">Cinder</a></h1>
	</div>

<!-- Generated by Doxygen 1.7.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacecinder.html">cinder</a>      </li>
      <li><a class="el" href="classcinder_1_1_surface_t.html">SurfaceT</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>cinder::SurfaceT&lt; T &gt; Class Template Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="cinder::SurfaceT" -->
<p>An in-memory representation of an image. <a class="el" href="guide__impl_shared.html">Implicitly shared object</a>.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_surface_8h_source.html">Surface.h</a>&gt;</code></p>

<p><a href="classcinder_1_1_surface_t-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t_1_1_const_iter.html">ConstIter</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience class for iterating the pixels of a Surface. The iteration is <code>const</code>, performing read-only operations on the Surface.  <a href="classcinder_1_1_surface_t_1_1_const_iter.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t_1_1_iter.html">Iter</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience class for iterating the pixels of a Surface.  <a href="classcinder_1_1_surface_t_1_1_iter.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#a785e8c6fabbdbaeb65712e4858833479">SurfaceT</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty Surface, which is the equivalent of NULL and should not be used directly.  <a href="#a785e8c6fabbdbaeb65712e4858833479"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#a34bcd91acdf1111d5da624a21e67f99a">SurfaceT</a> (int32_t width, int32_t height, bool alpha, <a class="el" href="classcinder_1_1_surface_channel_order.html">SurfaceChannelOrder</a> channelOrder=SurfaceChannelOrder::UNSPECIFIED)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a Surface object that is <em>height</em> and <em>width</em> pixels, an alpha channel based on <em>alpha</em>, and the channel order <em>channelOrder</em>.  <a href="#a34bcd91acdf1111d5da624a21e67f99a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#a7f8eb913b83effb58ee15badd198dcd0">SurfaceT</a> (int32_t width, int32_t height, bool alpha, const <a class="el" href="classcinder_1_1_surface_constraints.html">SurfaceConstraints</a> &amp;constraints)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#ac9004fd8b1e0c500e02fcdfbdbe571ed">SurfaceT</a> (T *data, int32_t width, int32_t height, int32_t rowBytes, <a class="el" href="classcinder_1_1_surface_channel_order.html">SurfaceChannelOrder</a> channelOrder)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a surface from the memory pointed to by <em>data</em>. Does not assume ownership of the memory in <em>data</em>, which consequently should not be freed while the Surface is still in use.  <a href="#ac9004fd8b1e0c500e02fcdfbdbe571ed"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#a55e994d9c8a799dd4a4540d6650f7ecb">SurfaceT</a> (<a class="el" href="namespacecinder.html#aca11590d504e68de86f3a57444c2eb70">ImageSourceRef</a> imageSource, const <a class="el" href="classcinder_1_1_surface_constraints.html">SurfaceConstraints</a> &amp;constraints=<a class="el" href="classcinder_1_1_surface_constraints_default.html">SurfaceConstraintsDefault</a>(), boost::tribool alpha=boost::logic::indeterminate)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a Surface object from an <a class="el" href="classcinder_1_1_image_source.html">ImageSource</a>, for instance from the result of a <a class="el" href="namespacecinder.html#a8d48244c4a93cc92a64a35d5800036ad" title="Loads an image from the file path path. Optional extension parameter allows specification of a file t...">loadImage()</a> call.  <a href="#a55e994d9c8a799dd4a4540d6650f7ecb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#a79defcf8e73b0526f26af3be914f78be">operator ImageSourceRef</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#a32a1e5d14987a74b858969eb5ee81c42">operator ImageTargetRef</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#a1b8928d870737daf9f59fdfb83fa51e4">getWidth</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the width of the Surface in pixels.  <a href="#a1b8928d870737daf9f59fdfb83fa51e4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#abbb727cb106dc1b4b537991ccd1a218d">getHeight</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the height of the Surface in pixels.  <a href="#abbb727cb106dc1b4b537991ccd1a218d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcinder_1_1_vec2.html">Vec2i</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#a240bf5253a4cfffa06a4ea6e07002331">getSize</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the Surface in pixels.  <a href="#a240bf5253a4cfffa06a4ea6e07002331"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#a24266e8d1474dc9f817183745c844791">getAspectRatio</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Surface aspect ratio, which is its width / height.  <a href="#a24266e8d1474dc9f817183745c844791"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcinder_1_1_area_t.html">Area</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#ab5c7c63efe35fc8c4c97531b4d20884e">getBounds</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the bounding Area of the Surface in pixels: [0,0]-(width,height)  <a href="#ab5c7c63efe35fc8c4c97531b4d20884e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#a82124f1cf056043b85248eacf472e225">hasAlpha</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the Surface contains an alpha channel.  <a href="#a82124f1cf056043b85248eacf472e225"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#a73e75b813f8af6255e3de692086abdd7">isPremultiplied</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the Surface color data is premultiplied by its alpha channel or not.  <a href="#a73e75b813f8af6255e3de692086abdd7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#af3cf7e047bb742b97186cfca3a131cb3">setPremultiplied</a> (bool premult=true) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether the Surface color data should be interpreted as being premultiplied by its alpha channel or not.  <a href="#af3cf7e047bb742b97186cfca3a131cb3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#a81a5f9c0c1768c751f3096d1fe83ab11">getRowBytes</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the width of a row of the Surface measured in bytes, which is not necessarily <a class="el" href="classcinder_1_1_surface_t.html#a1b8928d870737daf9f59fdfb83fa51e4" title="Returns the width of the Surface in pixels.">getWidth()</a> * <a class="el" href="classcinder_1_1_surface_t.html#a550c975403a6f65c15348a6c87ac338b" title="Returns the amount to increment a T* to increment by a pixel. Analogous to the number of channels...">getPixelInc()</a>  <a href="#a81a5f9c0c1768c751f3096d1fe83ab11"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#a550c975403a6f65c15348a6c87ac338b">getPixelInc</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the amount to increment a T* to increment by a pixel. Analogous to the number of channels, which is either 3 or 4.  <a href="#a550c975403a6f65c15348a6c87ac338b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcinder_1_1_surface_t.html">SurfaceT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#a29d86f9b1875c30ac38dfb6447245049">clone</a> (bool copyPixels=true) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new Surface which is a duplicate. If <em>copyPixels</em> the pixel values are copied, otherwise the clone's pixels remain uninitialized.  <a href="#a29d86f9b1875c30ac38dfb6447245049"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcinder_1_1_surface_t.html">SurfaceT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#a1c2e20f388b53fb6868c5ba393f0ecfe">clone</a> (const <a class="el" href="classcinder_1_1_area_t.html">Area</a> &amp;area, bool copyPixels=true) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new Surface which is a duplicate of an Area <em>area</em>. If <em>copyPixels</em> the pixel values are copied, otherwise the clone's pixels remain uninitialized.  <a href="#a1c2e20f388b53fb6868c5ba393f0ecfe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#a87dd5a31c22eab567c6d6be938518cd6">getData</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retuns the raw data of an image as a pointer to either uin8t_t values in the case of a Surface8u or floats in the case of a Surface32f.  <a href="#a87dd5a31c22eab567c6d6be938518cd6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#ab91cd98ff60c2a42f80c6e35fdbf9840">getData</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#a42de94fd28f7d2cd9466a3e5818cb97b">getData</a> (const <a class="el" href="classcinder_1_1_vec2.html">Vec2i</a> &amp;offset)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#a36448ec39df80e5479cbc19a9b39d10d">getData</a> (const <a class="el" href="classcinder_1_1_vec2.html">Vec2i</a> &amp;offset) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#aecb65f9b84984d2401784d0eeb49a016">getDataRed</a> (const <a class="el" href="classcinder_1_1_vec2.html">Vec2i</a> &amp;offset)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the red channel data of the pixel located at <em>offset</em>. Result is a uint8_t* for Surface8u and a float* for Surface32f.  <a href="#aecb65f9b84984d2401784d0eeb49a016"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#a71c2e4bc4a0716733baa09cd71d98688">getDataRed</a> (const <a class="el" href="classcinder_1_1_vec2.html">Vec2i</a> &amp;offset) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#af06838ab7980d61a3e38c7d81c70cb1a">getDataGreen</a> (const <a class="el" href="classcinder_1_1_vec2.html">Vec2i</a> &amp;offset)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the green channel data of the pixel located at <em>offset</em>. Result is a uint8_t* for Surface8u and a float* for Surface32f.  <a href="#af06838ab7980d61a3e38c7d81c70cb1a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#a6ca0ac9cef34420506c50b0a4721187e">getDataGreen</a> (const <a class="el" href="classcinder_1_1_vec2.html">Vec2i</a> &amp;offset) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#abc96e9623b2cf02a2b6e271dd39de862">getDataBlue</a> (const <a class="el" href="classcinder_1_1_vec2.html">Vec2i</a> &amp;offset)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the blue channel data of the pixel located at <em>offset</em>. Result is a uint8_t* for Surface8u and a float* for Surface32f.  <a href="#abc96e9623b2cf02a2b6e271dd39de862"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#a60614c57a4e35717999c322e562a8777">getDataBlue</a> (const <a class="el" href="classcinder_1_1_vec2.html">Vec2i</a> &amp;offset) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#add41dcdc946d694e77a205a3f655d40d">getDataAlpha</a> (const <a class="el" href="classcinder_1_1_vec2.html">Vec2i</a> &amp;offset)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the alpha channel data of the pixel located at <em>offset</em>. Result is a uint8_t* for Surface8u and a float* for Surface32f. Undefined for Surfaces without an alpha channel.  <a href="#add41dcdc946d694e77a205a3f655d40d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#ac40094fa0fa5d0448c41fbaabb67ba15">getDataAlpha</a> (const <a class="el" href="classcinder_1_1_vec2.html">Vec2i</a> &amp;offset) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#ae1252ffdf7852caccfd03b23df157467">setDeallocator</a> (void(*aDeallocatorFunc)(void *), void *aDeallocatorRefcon)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcinder_1_1_surface_channel_order.html">SurfaceChannelOrder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#af12c7558fadb5a922d1d086c884bd10c">getChannelOrder</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the channel order of the Surface, the in-memory ordering of the channels of each pixel.  <a href="#af12c7558fadb5a922d1d086c884bd10c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#a93e1f09b8d4d98fad12977d4fffb0cf7">getRedOffset</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the in-memory offset relative to a pixel for the red data. For example, for RGBA, returns 0.  <a href="#a93e1f09b8d4d98fad12977d4fffb0cf7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#a2c390c3d39809c34fcbc653788d0b1e8">getGreenOffset</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the in-memory offset relative to a pixel for the red data. For example, for RGBA, returns 1.  <a href="#a2c390c3d39809c34fcbc653788d0b1e8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#a95ef6f9eaf2d5ea76a850497842a21a3">getBlueOffset</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the in-memory offset relative to a pixel for the red data. For example, for RGBA, returns 2.  <a href="#a95ef6f9eaf2d5ea76a850497842a21a3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#a072f2b80c7aca558f6cdb0997c1797a8">getAlphaOffset</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the in-memory offset relative to a pixel for the red data. For example, for RGBA, returns 3. Returns <a class="el" href="classcinder_1_1_surface_channel_order.html#a2736aa7fc825a2c8df63efc4afc54a07ae72ecc43e9d7c20bfeb89665268eaa3c">SurfaceChannelOrder::INVALID</a> in the absence of an alpha channel.  <a href="#a072f2b80c7aca558f6cdb0997c1797a8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#aaf07eae37706817ca0885d306b5cd0e1">setChannelOrder</a> (const <a class="el" href="classcinder_1_1_surface_channel_order.html">SurfaceChannelOrder</a> &amp;aChannelOrder)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the channel order of the Surface, the in-memory ordering of the channels of each pixel. Call does not modify any pixel data, but does modify its interpretation.  <a href="#aaf07eae37706817ca0885d306b5cd0e1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcinder_1_1_channel_t.html">ChannelT</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#ae9e3a626f08cc734005b91ad63eed1f0">getChannel</a> (uint8_t channelIndex)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to a Channel <em>channelIndex</em> indexed according to how the channels are arranged per the <a class="el" href="classcinder_1_1_surface_channel_order.html" title="Specifies the in-memory ordering of the channels of a Surface.">SurfaceChannelOrder</a>.  <a href="#ae9e3a626f08cc734005b91ad63eed1f0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcinder_1_1_channel_t.html">ChannelT</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#aa7e5e6da1ae553cae5d1485c2e66237a">getChannel</a> (uint8_t channelIndex) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reference to a Channel <em>channelIndex</em> indexed according to how the channels are arranged per the <a class="el" href="classcinder_1_1_surface_channel_order.html" title="Specifies the in-memory ordering of the channels of a Surface.">SurfaceChannelOrder</a>.  <a href="#aa7e5e6da1ae553cae5d1485c2e66237a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcinder_1_1_channel_t.html">ChannelT</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#ad18dfcdd556a475d3141cdba45602eec">getChannelRed</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the red Channel of the Surface.  <a href="#ad18dfcdd556a475d3141cdba45602eec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcinder_1_1_channel_t.html">ChannelT</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#a958b48daeefd05e0ff2c7c33e9c21aca">getChannelGreen</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the green Channel of the Surface.  <a href="#a958b48daeefd05e0ff2c7c33e9c21aca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcinder_1_1_channel_t.html">ChannelT</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#ae36bbf0e559edbca50c03e4d44790ae0">getChannelBlue</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the blue Channel of the Surface.  <a href="#ae36bbf0e559edbca50c03e4d44790ae0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcinder_1_1_channel_t.html">ChannelT</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#a822adcec9d90e990d7a4d8d6b79d8485">getChannelAlpha</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the alpha Channel of the Surface.  <a href="#a822adcec9d90e990d7a4d8d6b79d8485"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcinder_1_1_channel_t.html">ChannelT</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#af91d2903ff37e2b85ccd8786c6483d15">getChannelRed</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reference to the red Channel of the Surface.  <a href="#af91d2903ff37e2b85ccd8786c6483d15"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcinder_1_1_channel_t.html">ChannelT</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#a64a64d6c6418df75127d5f585a9b9e2f">getChannelGreen</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reference to the green Channel of the Surface.  <a href="#a64a64d6c6418df75127d5f585a9b9e2f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcinder_1_1_channel_t.html">ChannelT</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#a498f923a3235754d916b07ac3b9ca938">getChannelBlue</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reference to the blue Channel of the Surface.  <a href="#a498f923a3235754d916b07ac3b9ca938"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcinder_1_1_channel_t.html">ChannelT</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#ab432240ffbc3c0c5906e25d4ea96f674">getChannelAlpha</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reference to the alpha Channel of the Surface.  <a href="#ab432240ffbc3c0c5906e25d4ea96f674"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcinder_1_1_color_a_t.html">ColorAT</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#a862e892ced2cea8d422683ab82915012">getPixel</a> (<a class="el" href="classcinder_1_1_vec2.html">Vec2i</a> pos) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method for getting a single pixel. For performance-sensitive code consider <a class="el" href="classcinder_1_1_surface_t_1_1_iter.html">Surface::Iter</a> instead.  <a href="#a862e892ced2cea8d422683ab82915012"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#abeef32100150e5748551c074b433f6ab">setPixel</a> (<a class="el" href="classcinder_1_1_vec2.html">Vec2i</a> pos, const <a class="el" href="classcinder_1_1_color_t.html">ColorT</a>&lt; T &gt; &amp;c)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method for setting a single pixel. For performance-sensitive code consider <a class="el" href="classcinder_1_1_surface_t_1_1_iter.html">Surface::Iter</a> instead.  <a href="#abeef32100150e5748551c074b433f6ab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#a65b0c7a1d4ef7e749ec068df95fd9b42">setPixel</a> (<a class="el" href="classcinder_1_1_vec2.html">Vec2i</a> pos, const <a class="el" href="classcinder_1_1_color_a_t.html">ColorAT</a>&lt; T &gt; &amp;c)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method for setting a single pixel. For performance-sensitive code consider <a class="el" href="classcinder_1_1_surface_t_1_1_iter.html">Surface::Iter</a> instead.  <a href="#a65b0c7a1d4ef7e749ec068df95fd9b42"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#a73dda39e47f015905cc43471e7e426d3">copyFrom</a> (const <a class="el" href="classcinder_1_1_surface_t.html">SurfaceT</a>&lt; T &gt; &amp;srcSurface, const <a class="el" href="classcinder_1_1_area_t.html">Area</a> &amp;srcArea, const <a class="el" href="classcinder_1_1_vec2.html">Vec2i</a> &amp;relativeOffset=Vec2i::zero())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the Area <em>srcArea</em> of the Surface <em>srcSurface</em> to <em>this</em> Surface. The destination Area is <em>srcArea</em> offset by <em>relativeOffset</em>.  <a href="#a73dda39e47f015905cc43471e7e426d3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcinder_1_1_color_t.html">ColorT</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#a11c5d89e1bcdf1c0e70d36adc6bb6bc6">areaAverage</a> (const <a class="el" href="classcinder_1_1_area_t.html">Area</a> &amp;area) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an averaged color for the Area defined by <em>area</em>.  <a href="#a11c5d89e1bcdf1c0e70d36adc6bb6bc6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcinder_1_1_surface_t_1_1_iter.html">Iter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#a2d33a9fdbb5242e13e27c0dfc7fe7c33">getIter</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <a class="el" href="classcinder_1_1_surface_t_1_1_iter.html" title="Convenience class for iterating the pixels of a Surface.">Iter</a> which iterates the entire Surface.  <a href="#a2d33a9fdbb5242e13e27c0dfc7fe7c33"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcinder_1_1_surface_t_1_1_iter.html">Iter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#a8ed96afb9b9a7deb59e48e694dc2d3b1">getIter</a> (const <a class="el" href="classcinder_1_1_area_t.html">Area</a> &amp;area)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <a class="el" href="classcinder_1_1_surface_t_1_1_iter.html" title="Convenience class for iterating the pixels of a Surface.">Iter</a> which iterates the Area <em>area</em>.  <a href="#a8ed96afb9b9a7deb59e48e694dc2d3b1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcinder_1_1_surface_t_1_1_const_iter.html">ConstIter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#a9e3c36d49617eb6c833177e1dc940cce">getIter</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classcinder_1_1_surface_t_1_1_const_iter.html" title="Convenience class for iterating the pixels of a Surface. The iteration is const, performing read-only...">ConstIter</a> which iterates the entire Surface.  <a href="#a9e3c36d49617eb6c833177e1dc940cce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcinder_1_1_surface_t_1_1_const_iter.html">ConstIter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcinder_1_1_surface_t.html#adf005ed5921c23587fcdc470a9fe063b">getIter</a> (const <a class="el" href="classcinder_1_1_area_t.html">Area</a> &amp;area) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classcinder_1_1_surface_t_1_1_const_iter.html" title="Convenience class for iterating the pixels of a Surface. The iteration is const, performing read-only...">ConstIter</a> which iterates the Area <em>area</em>.  <a href="#adf005ed5921c23587fcdc470a9fe063b"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;typename T&gt;<br/>
 class cinder::SurfaceT&lt; T &gt;</h3>

<p>An in-memory representation of an image. <a class="el" href="guide__impl_shared.html">Implicitly shared object</a>. </p>
<p>A Surface always contains red, green and blue data, along with an optional alpha channel.<br/>
 <br/>
 Surfaces come in two primary configurations, the traditional 8-bits per channel represented by <a class="el" href="namespacecinder.html#ad8b046fa928d58861b60465ceda392c5">Surface8u</a>, and a float per channel, suitable for high dynamic range images, represented by <a class="el" href="namespacecinder.html#a69465422e6011583c33994f0280dcd29">Surface32f</a>. <em>Surface</em> is a short-hand synonym for <em>Surface8u</em>. <br/>
 <br/>
 Surfaces are a CPU-based image representation, and must be converted appropriately to be drawn using the GPU. For example, to be used with OpenGL, the <a class="el" href="classcinder_1_1gl_1_1_texture.html">gl::Texture</a> is a natural choice, and it can be constructed directly from a Surface.<br/>
 <br/>
 To manipulate individual pixels of a Surface, the <a class="el" href="classcinder_1_1_surface_t_1_1_iter.html">Surface::Iter</a> class can be used.<br/>
 <br/>
 To allocate a Surface that is 640x480 and has an alpha channel, use:<br/>
 <code>Surface mySurface( 640, 480, true );</code><br/>
 A Surface can be created from an image file using the result of <a class="el" href="namespacecinder.html#a8d48244c4a93cc92a64a35d5800036ad" title="Loads an image from the file path path. Optional extension parameter allows specification of a file t...">loadImage()</a>:<br/>
 <code>Surface bitmap( loadImage( "image.jpg" ) );</code><br/>
 <br/>
 The pixels of each row of a Surface are stored in contiguous memory, and the start of each row is offset from the previous by the stride (measured in bytes) returned by <a class="el" href="classcinder_1_1_surface_t.html#a81a5f9c0c1768c751f3096d1fe83ab11">getRowBytes()</a>. Pixels can be ordered in memory in a number of configurations, specified using the <a class="el" href="classcinder_1_1_surface_channel_order.html" title="Specifies the in-memory ordering of the channels of a Surface.">SurfaceChannelOrder</a> class. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="guide__images.html">Images in Cinder</a> </dd></dl>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a785e8c6fabbdbaeb65712e4858833479"></a><!-- doxytag: member="cinder::SurfaceT::SurfaceT" ref="a785e8c6fabbdbaeb65712e4858833479" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::<a class="el" href="classcinder_1_1_surface_t.html">SurfaceT</a> </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructs an empty Surface, which is the equivalent of NULL and should not be used directly. </p>

</div>
</div>
<a class="anchor" id="a34bcd91acdf1111d5da624a21e67f99a"></a><!-- doxytag: member="cinder::SurfaceT::SurfaceT" ref="a34bcd91acdf1111d5da624a21e67f99a" args="(int32_t width, int32_t height, bool alpha, SurfaceChannelOrder channelOrder=SurfaceChannelOrder::UNSPECIFIED)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::<a class="el" href="classcinder_1_1_surface_t.html">SurfaceT</a> </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"> <em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcinder_1_1_surface_channel_order.html">SurfaceChannelOrder</a>&#160;</td>
          <td class="paramname"> <em>channelOrder</em> = <code>SurfaceChannelOrder::UNSPECIFIED</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a Surface object that is <em>height</em> and <em>width</em> pixels, an alpha channel based on <em>alpha</em>, and the channel order <em>channelOrder</em>. </p>
<p>As an example, the following would create a 640x480 pixel surface with an alpha channel, and an RGBA channel order <code>Surface32f mySurface( 640, 480, true, SurfaceChannelOrder::RGBA );</code> </p>

</div>
</div>
<a class="anchor" id="a7f8eb913b83effb58ee15badd198dcd0"></a><!-- doxytag: member="cinder::SurfaceT::SurfaceT" ref="a7f8eb913b83effb58ee15badd198dcd0" args="(int32_t width, int32_t height, bool alpha, const SurfaceConstraints &amp;constraints)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::<a class="el" href="classcinder_1_1_surface_t.html">SurfaceT</a> </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"> <em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcinder_1_1_surface_constraints.html">SurfaceConstraints</a> &amp;&#160;</td>
          <td class="paramname"> <em>constraints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac9004fd8b1e0c500e02fcdfbdbe571ed"></a><!-- doxytag: member="cinder::SurfaceT::SurfaceT" ref="ac9004fd8b1e0c500e02fcdfbdbe571ed" args="(T *data, int32_t width, int32_t height, int32_t rowBytes, SurfaceChannelOrder channelOrder)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::<a class="el" href="classcinder_1_1_surface_t.html">SurfaceT</a> </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"> <em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"> <em>rowBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcinder_1_1_surface_channel_order.html">SurfaceChannelOrder</a>&#160;</td>
          <td class="paramname"> <em>channelOrder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructs a surface from the memory pointed to by <em>data</em>. Does not assume ownership of the memory in <em>data</em>, which consequently should not be freed while the Surface is still in use. </p>

</div>
</div>
<a class="anchor" id="a55e994d9c8a799dd4a4540d6650f7ecb"></a><!-- doxytag: member="cinder::SurfaceT::SurfaceT" ref="a55e994d9c8a799dd4a4540d6650f7ecb" args="(ImageSourceRef imageSource, const SurfaceConstraints &amp;constraints=SurfaceConstraintsDefault(), boost::tribool alpha=boost::logic::indeterminate)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::<a class="el" href="classcinder_1_1_surface_t.html">SurfaceT</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecinder.html#aca11590d504e68de86f3a57444c2eb70">ImageSourceRef</a>&#160;</td>
          <td class="paramname"> <em>imageSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcinder_1_1_surface_constraints.html">SurfaceConstraints</a> &amp;&#160;</td>
          <td class="paramname"> <em>constraints</em> = <code><a class="el" href="classcinder_1_1_surface_constraints_default.html">SurfaceConstraintsDefault</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::tribool&#160;</td>
          <td class="paramname"> <em>alpha</em> = <code>boost::logic::indeterminate</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a Surface object from an <a class="el" href="classcinder_1_1_image_source.html">ImageSource</a>, for instance from the result of a <a class="el" href="namespacecinder.html#a8d48244c4a93cc92a64a35d5800036ad" title="Loads an image from the file path path. Optional extension parameter allows specification of a file t...">loadImage()</a> call. </p>
<p>To load an image from a resource, pass the result of the <a class="el" href="namespacecinder.html#a8d48244c4a93cc92a64a35d5800036ad" title="Loads an image from the file path path. Optional extension parameter allows specification of a file t...">loadImage()</a> call to the Surface constructor as shown below <code>Surface mySurface = Surface( loadImage( loadResource( RES ) );</code> </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a79defcf8e73b0526f26af3be914f78be"></a><!-- doxytag: member="cinder::SurfaceT::operator ImageSourceRef" ref="a79defcf8e73b0526f26af3be914f78be" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::operator <a class="el" href="namespacecinder.html#aca11590d504e68de86f3a57444c2eb70">ImageSourceRef</a> </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a32a1e5d14987a74b858969eb5ee81c42"></a><!-- doxytag: member="cinder::SurfaceT::operator ImageTargetRef" ref="a32a1e5d14987a74b858969eb5ee81c42" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::operator <a class="el" href="namespacecinder.html#aa5caf83179f34be27691363934b85afb">ImageTargetRef</a> </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a1b8928d870737daf9f59fdfb83fa51e4"></a><!-- doxytag: member="cinder::SurfaceT::getWidth" ref="a1b8928d870737daf9f59fdfb83fa51e4" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int32_t <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::getWidth </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the width of the Surface in pixels. </p>

</div>
</div>
<a class="anchor" id="abbb727cb106dc1b4b537991ccd1a218d"></a><!-- doxytag: member="cinder::SurfaceT::getHeight" ref="abbb727cb106dc1b4b537991ccd1a218d" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int32_t <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::getHeight </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the height of the Surface in pixels. </p>

</div>
</div>
<a class="anchor" id="a240bf5253a4cfffa06a4ea6e07002331"></a><!-- doxytag: member="cinder::SurfaceT::getSize" ref="a240bf5253a4cfffa06a4ea6e07002331" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcinder_1_1_vec2.html">Vec2i</a> <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::getSize </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the size of the Surface in pixels. </p>

</div>
</div>
<a class="anchor" id="a24266e8d1474dc9f817183745c844791"></a><!-- doxytag: member="cinder::SurfaceT::getAspectRatio" ref="a24266e8d1474dc9f817183745c844791" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::getAspectRatio </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the Surface aspect ratio, which is its width / height. </p>

</div>
</div>
<a class="anchor" id="ab5c7c63efe35fc8c4c97531b4d20884e"></a><!-- doxytag: member="cinder::SurfaceT::getBounds" ref="ab5c7c63efe35fc8c4c97531b4d20884e" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcinder_1_1_area_t.html">Area</a> <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::getBounds </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the bounding Area of the Surface in pixels: [0,0]-(width,height) </p>

</div>
</div>
<a class="anchor" id="a82124f1cf056043b85248eacf472e225"></a><!-- doxytag: member="cinder::SurfaceT::hasAlpha" ref="a82124f1cf056043b85248eacf472e225" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::hasAlpha </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns whether the Surface contains an alpha channel. </p>

</div>
</div>
<a class="anchor" id="a73e75b813f8af6255e3de692086abdd7"></a><!-- doxytag: member="cinder::SurfaceT::isPremultiplied" ref="a73e75b813f8af6255e3de692086abdd7" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::isPremultiplied </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns whether the Surface color data is premultiplied by its alpha channel or not. </p>

</div>
</div>
<a class="anchor" id="af3cf7e047bb742b97186cfca3a131cb3"></a><!-- doxytag: member="cinder::SurfaceT::setPremultiplied" ref="af3cf7e047bb742b97186cfca3a131cb3" args="(bool premult=true) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::setPremultiplied </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>premult</em> = <code>true</code>&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets whether the Surface color data should be interpreted as being premultiplied by its alpha channel or not. </p>

</div>
</div>
<a class="anchor" id="a81a5f9c0c1768c751f3096d1fe83ab11"></a><!-- doxytag: member="cinder::SurfaceT::getRowBytes" ref="a81a5f9c0c1768c751f3096d1fe83ab11" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int32_t <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::getRowBytes </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the width of a row of the Surface measured in bytes, which is not necessarily <a class="el" href="classcinder_1_1_surface_t.html#a1b8928d870737daf9f59fdfb83fa51e4" title="Returns the width of the Surface in pixels.">getWidth()</a> * <a class="el" href="classcinder_1_1_surface_t.html#a550c975403a6f65c15348a6c87ac338b" title="Returns the amount to increment a T* to increment by a pixel. Analogous to the number of channels...">getPixelInc()</a> </p>

</div>
</div>
<a class="anchor" id="a550c975403a6f65c15348a6c87ac338b"></a><!-- doxytag: member="cinder::SurfaceT::getPixelInc" ref="a550c975403a6f65c15348a6c87ac338b" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint8_t <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::getPixelInc </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the amount to increment a T* to increment by a pixel. Analogous to the number of channels, which is either 3 or 4. </p>

</div>
</div>
<a class="anchor" id="a29d86f9b1875c30ac38dfb6447245049"></a><!-- doxytag: member="cinder::SurfaceT::clone" ref="a29d86f9b1875c30ac38dfb6447245049" args="(bool copyPixels=true) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcinder_1_1_surface_t.html">SurfaceT</a>&lt; T &gt; <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::clone </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>copyPixels</em> = <code>true</code>&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a new Surface which is a duplicate. If <em>copyPixels</em> the pixel values are copied, otherwise the clone's pixels remain uninitialized. </p>

</div>
</div>
<a class="anchor" id="a1c2e20f388b53fb6868c5ba393f0ecfe"></a><!-- doxytag: member="cinder::SurfaceT::clone" ref="a1c2e20f388b53fb6868c5ba393f0ecfe" args="(const Area &amp;area, bool copyPixels=true) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcinder_1_1_surface_t.html">SurfaceT</a>&lt; T &gt; <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::clone </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcinder_1_1_area_t.html">Area</a> &amp;&#160;</td>
          <td class="paramname"> <em>area</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>copyPixels</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a new Surface which is a duplicate of an Area <em>area</em>. If <em>copyPixels</em> the pixel values are copied, otherwise the clone's pixels remain uninitialized. </p>

</div>
</div>
<a class="anchor" id="a87dd5a31c22eab567c6d6be938518cd6"></a><!-- doxytag: member="cinder::SurfaceT::getData" ref="a87dd5a31c22eab567c6d6be938518cd6" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::getData </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retuns the raw data of an image as a pointer to either uin8t_t values in the case of a Surface8u or floats in the case of a Surface32f. </p>

</div>
</div>
<a class="anchor" id="ab91cd98ff60c2a42f80c6e35fdbf9840"></a><!-- doxytag: member="cinder::SurfaceT::getData" ref="ab91cd98ff60c2a42f80c6e35fdbf9840" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::getData </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a42de94fd28f7d2cd9466a3e5818cb97b"></a><!-- doxytag: member="cinder::SurfaceT::getData" ref="a42de94fd28f7d2cd9466a3e5818cb97b" args="(const Vec2i &amp;offset)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::getData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcinder_1_1_vec2.html">Vec2i</a> &amp;&#160;</td>
          <td class="paramname"> <em>offset</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a36448ec39df80e5479cbc19a9b39d10d"></a><!-- doxytag: member="cinder::SurfaceT::getData" ref="a36448ec39df80e5479cbc19a9b39d10d" args="(const Vec2i &amp;offset) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::getData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcinder_1_1_vec2.html">Vec2i</a> &amp;&#160;</td>
          <td class="paramname"> <em>offset</em>&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aecb65f9b84984d2401784d0eeb49a016"></a><!-- doxytag: member="cinder::SurfaceT::getDataRed" ref="aecb65f9b84984d2401784d0eeb49a016" args="(const Vec2i &amp;offset)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::getDataRed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcinder_1_1_vec2.html">Vec2i</a> &amp;&#160;</td>
          <td class="paramname"> <em>offset</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a pointer to the red channel data of the pixel located at <em>offset</em>. Result is a uint8_t* for Surface8u and a float* for Surface32f. </p>

</div>
</div>
<a class="anchor" id="a71c2e4bc4a0716733baa09cd71d98688"></a><!-- doxytag: member="cinder::SurfaceT::getDataRed" ref="a71c2e4bc4a0716733baa09cd71d98688" args="(const Vec2i &amp;offset) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::getDataRed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcinder_1_1_vec2.html">Vec2i</a> &amp;&#160;</td>
          <td class="paramname"> <em>offset</em>&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af06838ab7980d61a3e38c7d81c70cb1a"></a><!-- doxytag: member="cinder::SurfaceT::getDataGreen" ref="af06838ab7980d61a3e38c7d81c70cb1a" args="(const Vec2i &amp;offset)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::getDataGreen </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcinder_1_1_vec2.html">Vec2i</a> &amp;&#160;</td>
          <td class="paramname"> <em>offset</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a pointer to the green channel data of the pixel located at <em>offset</em>. Result is a uint8_t* for Surface8u and a float* for Surface32f. </p>

</div>
</div>
<a class="anchor" id="a6ca0ac9cef34420506c50b0a4721187e"></a><!-- doxytag: member="cinder::SurfaceT::getDataGreen" ref="a6ca0ac9cef34420506c50b0a4721187e" args="(const Vec2i &amp;offset) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::getDataGreen </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcinder_1_1_vec2.html">Vec2i</a> &amp;&#160;</td>
          <td class="paramname"> <em>offset</em>&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="abc96e9623b2cf02a2b6e271dd39de862"></a><!-- doxytag: member="cinder::SurfaceT::getDataBlue" ref="abc96e9623b2cf02a2b6e271dd39de862" args="(const Vec2i &amp;offset)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::getDataBlue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcinder_1_1_vec2.html">Vec2i</a> &amp;&#160;</td>
          <td class="paramname"> <em>offset</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a pointer to the blue channel data of the pixel located at <em>offset</em>. Result is a uint8_t* for Surface8u and a float* for Surface32f. </p>

</div>
</div>
<a class="anchor" id="a60614c57a4e35717999c322e562a8777"></a><!-- doxytag: member="cinder::SurfaceT::getDataBlue" ref="a60614c57a4e35717999c322e562a8777" args="(const Vec2i &amp;offset) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::getDataBlue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcinder_1_1_vec2.html">Vec2i</a> &amp;&#160;</td>
          <td class="paramname"> <em>offset</em>&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="add41dcdc946d694e77a205a3f655d40d"></a><!-- doxytag: member="cinder::SurfaceT::getDataAlpha" ref="add41dcdc946d694e77a205a3f655d40d" args="(const Vec2i &amp;offset)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::getDataAlpha </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcinder_1_1_vec2.html">Vec2i</a> &amp;&#160;</td>
          <td class="paramname"> <em>offset</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a pointer to the alpha channel data of the pixel located at <em>offset</em>. Result is a uint8_t* for Surface8u and a float* for Surface32f. Undefined for Surfaces without an alpha channel. </p>

</div>
</div>
<a class="anchor" id="ac40094fa0fa5d0448c41fbaabb67ba15"></a><!-- doxytag: member="cinder::SurfaceT::getDataAlpha" ref="ac40094fa0fa5d0448c41fbaabb67ba15" args="(const Vec2i &amp;offset) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::getDataAlpha </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcinder_1_1_vec2.html">Vec2i</a> &amp;&#160;</td>
          <td class="paramname"> <em>offset</em>&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae1252ffdf7852caccfd03b23df157467"></a><!-- doxytag: member="cinder::SurfaceT::setDeallocator" ref="ae1252ffdf7852caccfd03b23df157467" args="(void(*aDeallocatorFunc)(void *), void *aDeallocatorRefcon)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::setDeallocator </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"> <em>aDeallocatorFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"> <em>aDeallocatorRefcon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the deallocator, an optional callback which will fire upon the Surface::Obj's destruction. This is useful when a Surface is wrapping another API's image data structure whose lifetime is tied to the Surface's. </p>

</div>
</div>
<a class="anchor" id="af12c7558fadb5a922d1d086c884bd10c"></a><!-- doxytag: member="cinder::SurfaceT::getChannelOrder" ref="af12c7558fadb5a922d1d086c884bd10c" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcinder_1_1_surface_channel_order.html">SurfaceChannelOrder</a>&amp; <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::getChannelOrder </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the channel order of the Surface, the in-memory ordering of the channels of each pixel. </p>

</div>
</div>
<a class="anchor" id="a93e1f09b8d4d98fad12977d4fffb0cf7"></a><!-- doxytag: member="cinder::SurfaceT::getRedOffset" ref="a93e1f09b8d4d98fad12977d4fffb0cf7" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint8_t <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::getRedOffset </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the in-memory offset relative to a pixel for the red data. For example, for RGBA, returns 0. </p>

</div>
</div>
<a class="anchor" id="a2c390c3d39809c34fcbc653788d0b1e8"></a><!-- doxytag: member="cinder::SurfaceT::getGreenOffset" ref="a2c390c3d39809c34fcbc653788d0b1e8" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint8_t <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::getGreenOffset </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the in-memory offset relative to a pixel for the red data. For example, for RGBA, returns 1. </p>

</div>
</div>
<a class="anchor" id="a95ef6f9eaf2d5ea76a850497842a21a3"></a><!-- doxytag: member="cinder::SurfaceT::getBlueOffset" ref="a95ef6f9eaf2d5ea76a850497842a21a3" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint8_t <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::getBlueOffset </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the in-memory offset relative to a pixel for the red data. For example, for RGBA, returns 2. </p>

</div>
</div>
<a class="anchor" id="a072f2b80c7aca558f6cdb0997c1797a8"></a><!-- doxytag: member="cinder::SurfaceT::getAlphaOffset" ref="a072f2b80c7aca558f6cdb0997c1797a8" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint8_t <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::getAlphaOffset </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the in-memory offset relative to a pixel for the red data. For example, for RGBA, returns 3. Returns <a class="el" href="classcinder_1_1_surface_channel_order.html#a2736aa7fc825a2c8df63efc4afc54a07ae72ecc43e9d7c20bfeb89665268eaa3c">SurfaceChannelOrder::INVALID</a> in the absence of an alpha channel. </p>

</div>
</div>
<a class="anchor" id="aaf07eae37706817ca0885d306b5cd0e1"></a><!-- doxytag: member="cinder::SurfaceT::setChannelOrder" ref="aaf07eae37706817ca0885d306b5cd0e1" args="(const SurfaceChannelOrder &amp;aChannelOrder)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::setChannelOrder </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcinder_1_1_surface_channel_order.html">SurfaceChannelOrder</a> &amp;&#160;</td>
          <td class="paramname"> <em>aChannelOrder</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the channel order of the Surface, the in-memory ordering of the channels of each pixel. Call does not modify any pixel data, but does modify its interpretation. </p>

</div>
</div>
<a class="anchor" id="ae9e3a626f08cc734005b91ad63eed1f0"></a><!-- doxytag: member="cinder::SurfaceT::getChannel" ref="ae9e3a626f08cc734005b91ad63eed1f0" args="(uint8_t channelIndex)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcinder_1_1_channel_t.html">ChannelT</a>&lt;T&gt;&amp; <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::getChannel </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"> <em>channelIndex</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a reference to a Channel <em>channelIndex</em> indexed according to how the channels are arranged per the <a class="el" href="classcinder_1_1_surface_channel_order.html" title="Specifies the in-memory ordering of the channels of a Surface.">SurfaceChannelOrder</a>. </p>

</div>
</div>
<a class="anchor" id="aa7e5e6da1ae553cae5d1485c2e66237a"></a><!-- doxytag: member="cinder::SurfaceT::getChannel" ref="aa7e5e6da1ae553cae5d1485c2e66237a" args="(uint8_t channelIndex) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcinder_1_1_channel_t.html">ChannelT</a>&lt;T&gt;&amp; <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::getChannel </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"> <em>channelIndex</em>&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a const reference to a Channel <em>channelIndex</em> indexed according to how the channels are arranged per the <a class="el" href="classcinder_1_1_surface_channel_order.html" title="Specifies the in-memory ordering of the channels of a Surface.">SurfaceChannelOrder</a>. </p>

</div>
</div>
<a class="anchor" id="ad18dfcdd556a475d3141cdba45602eec"></a><!-- doxytag: member="cinder::SurfaceT::getChannelRed" ref="ad18dfcdd556a475d3141cdba45602eec" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcinder_1_1_channel_t.html">ChannelT</a>&lt;T&gt;&amp; <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::getChannelRed </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a reference to the red Channel of the Surface. </p>

</div>
</div>
<a class="anchor" id="a958b48daeefd05e0ff2c7c33e9c21aca"></a><!-- doxytag: member="cinder::SurfaceT::getChannelGreen" ref="a958b48daeefd05e0ff2c7c33e9c21aca" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcinder_1_1_channel_t.html">ChannelT</a>&lt;T&gt;&amp; <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::getChannelGreen </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a reference to the green Channel of the Surface. </p>

</div>
</div>
<a class="anchor" id="ae36bbf0e559edbca50c03e4d44790ae0"></a><!-- doxytag: member="cinder::SurfaceT::getChannelBlue" ref="ae36bbf0e559edbca50c03e4d44790ae0" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcinder_1_1_channel_t.html">ChannelT</a>&lt;T&gt;&amp; <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::getChannelBlue </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a reference to the blue Channel of the Surface. </p>

</div>
</div>
<a class="anchor" id="a822adcec9d90e990d7a4d8d6b79d8485"></a><!-- doxytag: member="cinder::SurfaceT::getChannelAlpha" ref="a822adcec9d90e990d7a4d8d6b79d8485" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcinder_1_1_channel_t.html">ChannelT</a>&lt;T&gt;&amp; <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::getChannelAlpha </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a reference to the alpha Channel of the Surface. </p>
<p>Undefined in the absence of an alpha channel. </p>

</div>
</div>
<a class="anchor" id="af91d2903ff37e2b85ccd8786c6483d15"></a><!-- doxytag: member="cinder::SurfaceT::getChannelRed" ref="af91d2903ff37e2b85ccd8786c6483d15" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcinder_1_1_channel_t.html">ChannelT</a>&lt;T&gt;&amp; <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::getChannelRed </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a const reference to the red Channel of the Surface. </p>

</div>
</div>
<a class="anchor" id="a64a64d6c6418df75127d5f585a9b9e2f"></a><!-- doxytag: member="cinder::SurfaceT::getChannelGreen" ref="a64a64d6c6418df75127d5f585a9b9e2f" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcinder_1_1_channel_t.html">ChannelT</a>&lt;T&gt;&amp; <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::getChannelGreen </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a const reference to the green Channel of the Surface. </p>

</div>
</div>
<a class="anchor" id="a498f923a3235754d916b07ac3b9ca938"></a><!-- doxytag: member="cinder::SurfaceT::getChannelBlue" ref="a498f923a3235754d916b07ac3b9ca938" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcinder_1_1_channel_t.html">ChannelT</a>&lt;T&gt;&amp; <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::getChannelBlue </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a const reference to the blue Channel of the Surface. </p>

</div>
</div>
<a class="anchor" id="ab432240ffbc3c0c5906e25d4ea96f674"></a><!-- doxytag: member="cinder::SurfaceT::getChannelAlpha" ref="ab432240ffbc3c0c5906e25d4ea96f674" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcinder_1_1_channel_t.html">ChannelT</a>&lt;T&gt;&amp; <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::getChannelAlpha </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a const reference to the alpha Channel of the Surface. </p>
<p>Undefined in the absence of an alpha channel. </p>

</div>
</div>
<a class="anchor" id="a862e892ced2cea8d422683ab82915012"></a><!-- doxytag: member="cinder::SurfaceT::getPixel" ref="a862e892ced2cea8d422683ab82915012" args="(Vec2i pos) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcinder_1_1_color_a_t.html">ColorAT</a>&lt;T&gt; <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::getPixel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcinder_1_1_vec2.html">Vec2i</a>&#160;</td>
          <td class="paramname"> <em>pos</em>&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience method for getting a single pixel. For performance-sensitive code consider <a class="el" href="classcinder_1_1_surface_t_1_1_iter.html">Surface::Iter</a> instead. </p>

</div>
</div>
<a class="anchor" id="abeef32100150e5748551c074b433f6ab"></a><!-- doxytag: member="cinder::SurfaceT::setPixel" ref="abeef32100150e5748551c074b433f6ab" args="(Vec2i pos, const ColorT&lt; T &gt; &amp;c)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::setPixel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcinder_1_1_vec2.html">Vec2i</a>&#160;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcinder_1_1_color_t.html">ColorT</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"> <em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience method for setting a single pixel. For performance-sensitive code consider <a class="el" href="classcinder_1_1_surface_t_1_1_iter.html">Surface::Iter</a> instead. </p>

</div>
</div>
<a class="anchor" id="a65b0c7a1d4ef7e749ec068df95fd9b42"></a><!-- doxytag: member="cinder::SurfaceT::setPixel" ref="a65b0c7a1d4ef7e749ec068df95fd9b42" args="(Vec2i pos, const ColorAT&lt; T &gt; &amp;c)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::setPixel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcinder_1_1_vec2.html">Vec2i</a>&#160;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcinder_1_1_color_a_t.html">ColorAT</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"> <em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience method for setting a single pixel. For performance-sensitive code consider <a class="el" href="classcinder_1_1_surface_t_1_1_iter.html">Surface::Iter</a> instead. </p>

</div>
</div>
<a class="anchor" id="a73dda39e47f015905cc43471e7e426d3"></a><!-- doxytag: member="cinder::SurfaceT::copyFrom" ref="a73dda39e47f015905cc43471e7e426d3" args="(const SurfaceT&lt; T &gt; &amp;srcSurface, const Area &amp;srcArea, const Vec2i &amp;relativeOffset=Vec2i::zero())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::copyFrom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcinder_1_1_surface_t.html">SurfaceT</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"> <em>srcSurface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcinder_1_1_area_t.html">Area</a> &amp;&#160;</td>
          <td class="paramname"> <em>srcArea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcinder_1_1_vec2.html">Vec2i</a> &amp;&#160;</td>
          <td class="paramname"> <em>relativeOffset</em> = <code>Vec2i::zero()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies the Area <em>srcArea</em> of the Surface <em>srcSurface</em> to <em>this</em> Surface. The destination Area is <em>srcArea</em> offset by <em>relativeOffset</em>. </p>

</div>
</div>
<a class="anchor" id="a11c5d89e1bcdf1c0e70d36adc6bb6bc6"></a><!-- doxytag: member="cinder::SurfaceT::areaAverage" ref="a11c5d89e1bcdf1c0e70d36adc6bb6bc6" args="(const Area &amp;area) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcinder_1_1_color_t.html">ColorT</a>&lt; T &gt; <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::areaAverage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcinder_1_1_area_t.html">Area</a> &amp;&#160;</td>
          <td class="paramname"> <em>area</em>&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns an averaged color for the Area defined by <em>area</em>. </p>

</div>
</div>
<a class="anchor" id="a2d33a9fdbb5242e13e27c0dfc7fe7c33"></a><!-- doxytag: member="cinder::SurfaceT::getIter" ref="a2d33a9fdbb5242e13e27c0dfc7fe7c33" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcinder_1_1_surface_t_1_1_iter.html">Iter</a> <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::getIter </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns an <a class="el" href="classcinder_1_1_surface_t_1_1_iter.html" title="Convenience class for iterating the pixels of a Surface.">Iter</a> which iterates the entire Surface. </p>

</div>
</div>
<a class="anchor" id="a8ed96afb9b9a7deb59e48e694dc2d3b1"></a><!-- doxytag: member="cinder::SurfaceT::getIter" ref="a8ed96afb9b9a7deb59e48e694dc2d3b1" args="(const Area &amp;area)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcinder_1_1_surface_t_1_1_iter.html">Iter</a> <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::getIter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcinder_1_1_area_t.html">Area</a> &amp;&#160;</td>
          <td class="paramname"> <em>area</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns an <a class="el" href="classcinder_1_1_surface_t_1_1_iter.html" title="Convenience class for iterating the pixels of a Surface.">Iter</a> which iterates the Area <em>area</em>. </p>

</div>
</div>
<a class="anchor" id="a9e3c36d49617eb6c833177e1dc940cce"></a><!-- doxytag: member="cinder::SurfaceT::getIter" ref="a9e3c36d49617eb6c833177e1dc940cce" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcinder_1_1_surface_t_1_1_const_iter.html">ConstIter</a> <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::getIter </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a <a class="el" href="classcinder_1_1_surface_t_1_1_const_iter.html" title="Convenience class for iterating the pixels of a Surface. The iteration is const, performing read-only...">ConstIter</a> which iterates the entire Surface. </p>

</div>
</div>
<a class="anchor" id="adf005ed5921c23587fcdc470a9fe063b"></a><!-- doxytag: member="cinder::SurfaceT::getIter" ref="adf005ed5921c23587fcdc470a9fe063b" args="(const Area &amp;area) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcinder_1_1_surface_t_1_1_const_iter.html">ConstIter</a> <a class="el" href="classcinder_1_1_surface_t.html">cinder::SurfaceT</a>&lt; T &gt;::getIter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcinder_1_1_area_t.html">Area</a> &amp;&#160;</td>
          <td class="paramname"> <em>area</em>&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a <a class="el" href="classcinder_1_1_surface_t_1_1_const_iter.html" title="Convenience class for iterating the pixels of a Surface. The iteration is const, performing read-only...">ConstIter</a> which iterates the Area <em>area</em>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/cinder/<a class="el" href="_surface_8h_source.html">Surface.h</a></li>
<li>src/cinder/<a class="el" href="_surface_8cpp.html">Surface.cpp</a></li>
</ul>
</div>
	<div class="footer">
		<p> </p>
	</div>
</div>	
</body>
</html>
